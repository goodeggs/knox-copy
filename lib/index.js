// Generated by CoffeeScript 1.6.3
(function() {
  var KeyStream, Parser, backoff, ensureBuffer, guzzle, isArray, knox, qs, streamWorker, stripLeadingSlash, swapPrefix, waterfall;

  qs = require('querystring');

  isArray = require('util').isArray;

  waterfall = require('async').waterfall;

  knox = require('knox');

  Parser = require('xml2js').Parser;

  KeyStream = require('./key_stream');

  backoff = require('oibackoff').backoff({
    algorithm: 'exponential',
    delayRatio: 0.5,
    maxTries: 4
  });

  streamWorker = require('stream-worker');

  stripLeadingSlash = function(key) {
    return key.replace(/^\//, '');
  };

  swapPrefix = function(key, oldPre, newPre) {
    return "" + newPre + "/" + (stripLeadingSlash(key.slice(oldPre.length)));
  };

  ensureBuffer = function(data) {
    return Buffer.isBuffer(data) && data || new Buffer(data);
  };

  /*
  Read a whole stream into a buffer.
  */


  guzzle = function(stream, cb) {
    var buffers;
    buffers = [];
    stream.on('data', function(chunk) {
      return buffers.push(ensureBuffer(chunk));
    });
    stream.on('error', function(err) {
      return cb(err);
    });
    return stream.on('end', function() {
      return cb(null, Buffer.concat(buffers));
    });
  };

  /*
  Callback gets a JSON representation of a page of S3 Object keys.
  */


  knox.prototype.listPageOfKeys = function(_arg, cb) {
    var error, headers, marker, maxKeys, prefix,
      _this = this;
    maxKeys = _arg.maxKeys, marker = _arg.marker, prefix = _arg.prefix, headers = _arg.headers;
    if (maxKeys == null) {
      maxKeys = 1000;
    }
    if (headers == null) {
      headers = {};
    }
    if (prefix != null) {
      prefix = stripLeadingSlash(prefix);
    }
    if (marker != null) {
      marker = stripLeadingSlash(marker);
    }
    error = function(err) {
      return cb(new Error("Error listing bucket " + {
        marker: marker,
        prefix: prefix
      } + ":", err));
    };
    return waterfall([
      function(next) {
        var req;
        req = _this.request('GET', '/', headers);
        req.path += "?" + qs.stringify({
          'max-keys': maxKeys,
          prefix: prefix,
          marker: marker
        });
        req.on('error', error);
        req.on('response', function(res) {
          if (res.statusCode === 200) {
            return guzzle(res, next);
          } else {
            return error(res);
          }
        });
        return req.end();
      }, (new Parser({
        explicitArray: false,
        explicitRoot: false
      })).parseString, function(page, next) {
        page.IsTruncated = page.IsTruncated === 'true';
        page.Contents = isArray(page.Contents) ? page.Contents : page.Contents != null ? [page.Contents] : [];
        return next(null, page);
      }
    ], function(err, page) {
      if (err != null) {
        return error(err);
      } else {
        return cb(null, page);
      }
    });
  };

  knox.prototype.streamKeys = function(_arg) {
    var maxKeysPerRequest, prefix, _ref;
    _ref = _arg != null ? _arg : {}, prefix = _ref.prefix, maxKeysPerRequest = _ref.maxKeysPerRequest;
    return new KeyStream({
      prefix: prefix,
      client: this,
      maxKeysPerRequest: maxKeysPerRequest
    });
  };

  knox.prototype.copyBucket = function(_arg, cb) {
    var count, fail, failed, fromBucket, fromClient, fromPrefix, headers, keyStream, toPrefix,
      _this = this;
    fromBucket = _arg.fromBucket, fromPrefix = _arg.fromPrefix, toPrefix = _arg.toPrefix, headers = _arg.headers;
    if (fromBucket == null) {
      fromBucket = this.bucket;
    }
    fromClient = knox.createClient({
      key: this.key,
      secret: this.secret,
      bucket: fromBucket,
      token: this.token
    });
    fromPrefix = fromPrefix && stripLeadingSlash(fromPrefix) || '';
    toPrefix = toPrefix && stripLeadingSlash(toPrefix) || '';
    count = 0;
    failed = false;
    fail = function(err) {
      if (failed) {
        return;
      }
      failed = true;
      return cb(err, count);
    };
    keyStream = fromClient.streamKeys({
      prefix: fromPrefix
    });
    keyStream.on('error', fail);
    return streamWorker(keyStream, 5, function(key, done) {
      var toKey;
      toKey = swapPrefix(key, fromPrefix, toPrefix);
      return backoff(function(cb) {
        return fromClient.copyFileTo(key, _this.bucket, toKey, headers, function(err, res) {
          if (err != null) {
            return cb(err);
          } else if (res.statusCode !== 200) {
            return cb(new Error("" + res.statusCode + " response copying key " + key));
          } else {
            return cb();
          }
        });
      }, function(err) {
        if (err != null) {
          fail(err);
        }
        count++;
        return done();
      });
    }, function() {
      if (!failed) {
        return cb(null, count);
      }
    });
  };

  module.exports = knox;

}).call(this);
